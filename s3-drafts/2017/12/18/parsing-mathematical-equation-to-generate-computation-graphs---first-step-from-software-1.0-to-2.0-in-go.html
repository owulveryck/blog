<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->

<meta property="og:title" content="Parsing mathematical equation to generate computation graphs - First step from software 1.0 to 2.0 in go" />
<meta property="og:description" content="In a previous article, I described an implementation of an RNN from scratch in go. The target is to use the RNN as a processing unit. It can become a portable tool usable on any platform and able to grab and process data where they are (for example to find the root-cause of an incident, or as a helper decision tool for capacity management).
Note I stick to go, because I have in mind that someday this tool could act as a node of a processing network that would communicate via a tuple space." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog.owulveryck.info/2017/12/18/parsing-mathematical-equation-to-generate-computation-graphs---first-step-from-software-1.0-to-2.0-in-go.html" />

  <meta property="og:image" content="https://blog.owulveryck.info/assets/lstm/LSTM-cell.png" />



<meta property="article:published_time" content="2017-12-18T16:47:27&#43;01:00"/>

<meta property="article:modified_time" content="2017-12-18T16:47:27&#43;01:00"/>












<meta itemprop="name" content="Parsing mathematical equation to generate computation graphs - First step from software 1.0 to 2.0 in go">
<meta itemprop="description" content="In a previous article, I described an implementation of an RNN from scratch in go. The target is to use the RNN as a processing unit. It can become a portable tool usable on any platform and able to grab and process data where they are (for example to find the root-cause of an incident, or as a helper decision tool for capacity management).
Note I stick to go, because I have in mind that someday this tool could act as a node of a processing network that would communicate via a tuple space.">


<meta itemprop="datePublished" content="2017-12-18T16:47:27&#43;01:00" />
<meta itemprop="dateModified" content="2017-12-18T16:47:27&#43;01:00" />
<meta itemprop="wordCount" content="2340">

  <meta itemprop="image" content="https://blog.owulveryck.info/assets/lstm/LSTM-cell.png">



<meta itemprop="keywords" content="" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image:src" content="https://blog.owulveryck.info/assets/lstm/LSTM-cell.png"/>
<meta name="twitter:title" content="Parsing mathematical equation to generate computation graphs - First step from software 1.0 to 2.0 in go"/>
<meta name="twitter:description" content="In a previous article, I described an implementation of an RNN from scratch in go. The target is to use the RNN as a processing unit. It can become a portable tool usable on any platform and able to grab and process data where they are (for example to find the root-cause of an incident, or as a helper decision tool for capacity management).
Note I stick to go, because I have in mind that someday this tool could act as a node of a processing network that would communicate via a tuple space."/>
<meta name="twitter:site" content="@owulveryck"/>








<meta name="generator" content="Hugo 0.31.1" />


    <link rel="canonical" href="https://blog.owulveryck.info/2017/12/18/parsing-mathematical-equation-to-generate-computation-graphs---first-step-from-software-1.0-to-2.0-in-go.html">

    <title>Parsing mathematical equation to generate computation graphs - First step from software 1.0 to 2.0 in go | Unladen swallow</title>
    <link rel="apple-touch-icon" sizes="57x57" href="/assets/icons/apple-icon-57x57.png" />
    <link rel="apple-touch-icon" sizes="72x72" href="/assets/icons/apple-icon-72x72.png" />
    <link rel="apple-touch-icon" sizes="114x114" href="/assets/icons/apple-icon-114x114.png" />
    <link rel="apple-touch-icon" sizes="144x144" href="/assets/icons/apple-icon-144x144.png" />
    <meta name="apple-mobile-web-app-capable" content="yes" />


    <!-- combined, minified CSS -->
    <link href="https://blog.owulveryck.info/css/syntax.css" rel="stylesheet">
    <link href="https://blog.owulveryck.info/css/style.css" rel="stylesheet">
    <link href="https://blog.owulveryck.info/css/custom.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Pacifico|Cormorant+Garamond|Open+Sans" rel="stylesheet">

    

    
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-69673850-1', 'auto');
ga('send', 'pageview');
</script>
<script async src='//www.google-analytics.com/analytics.js'></script>


    

    
<script src='//cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>
<script type="text/x-mathjax-config"> MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}}); </script>


  </head>

  <body>

    <div class="blog-masthead">
      <div class="container">
        <nav class="nav blog-nav">
          <a class="nav-link " href="https://blog.owulveryck.info/">Home</a>
          
          
          <a class="nav-link" href="https://blog.owulveryck.info/about.html">About me</a>
          
          
        </nav>
      </div>
    </div>

    <header class="blog-header">
      <div class="container">
        <h1 class="blog-title"><a href="https://blog.owulveryck.info/" rel="home">Unladen swallow</a></h1>
        <p class="lead blog-description">Olivier Wulveryck&rsquo;s (tech) blog</p>
      </div>
    </header>

    <div class="container">
      <div class="row">
        <div class="col-sm-8 blog-main">

          


<article class="blog-post">
  <header>
  <div class="container">
  <div class="row">
    <div class="col-sm-10">
    <h2 class="blog-post-title"><a href="https://blog.owulveryck.info/2017/12/18/parsing-mathematical-equation-to-generate-computation-graphs---first-step-from-software-1.0-to-2.0-in-go.html">Parsing mathematical equation to generate computation graphs - First step from software 1.0 to 2.0 in go</a></h2>
    <p class="blog-post-meta"><time datetime="2017-12-18T16:47:27&#43;01:00">Mon Dec 18, 2017</time> by Olivier Wulveryck</p>
    </div>
    <div class="col-sm-2 frame-round">
  <a href='https://blog.owulveryck.info/2017/12/18/parsing-mathematical-equation-to-generate-computation-graphs---first-step-from-software-1.0-to-2.0-in-go.html'>
      
        <div class="crop">
      <img src="/assets/lstm/LSTM-cell.png" alt=""></img>
    </div>
      
    </a>
    </div>

    </div>
  </div>

  </header>

  

<p>In a previous article, I described an implementation of an RNN from scratch in go.
The target is to use the RNN as a processing unit. It can become a portable tool usable on any platform and able to grab and process data where they are
(for example to find the root-cause of an incident, or as a helper decision tool for capacity management).</p>

<p><em>Note</em> I stick to go, because I have in mind that someday this tool could act as a node of a processing network that would communicate via a tuple space.
All the node would work in choreography. The set of nodes would be a kind of distributed bot that could monitor a complete IT. That is for another story in a couple of years&hellip;</p>

<p>Back to <sup>2017</sup>&frasl;<sub>2018</sub>: the purpose of this article is to describe a way to code in software 1.0 an execution machine for a software 2.0.</p>

<p>I will first explain the concepts.
Then I will explain why a LSTM (a certain kind of neural network) is a software 2.0.
Then I will describe a way to parse and execute this software 2.0 on a machine coded in go (software 1.0).</p>

<h1 id="considerations-about-software-1-0-and-software-2-0">Considerations about software 1.0 and software 2.0</h1>

<h2 id="what-is-a-software">What is a software?</h2>

<p>It is sequence of bits and bytes that can be computed, and that produces a result (the solution of a problem for example).</p>

<p>To build a software until now, a compiler is used. Its goal is to turn a &ldquo;human readable sequence of characters&rdquo;, called code, into the sequence of bytes.</p>

<p>This sequence of bytes is evaluated and executed by a machine at run time. Depending on the input, the execution produces (hopefully) the expected output.</p>

<p>The art of programming, is, in essence, the faculty for a human to describe the solution of a problem and to express it in a computer language.</p>

<h2 id="what-is-software-2-0">What is software 2.0?</h2>

<p>I discovered the concept of software 2.0 thanks to <a href="https://medium.com/@karpathy/software-2-0-a64152b37c35">Andrej Karpathy&rsquo;s blog</a>.
The idea is similar to any software: a compiler is used to turn a sequence of code into a sequence of bytes. This sequence is interpreted by a machine.</p>

<p>The difference is that the code is a sequence of mathematical equations (called model). Those equations are composed of variables and &ldquo;constants&rdquo;. Let&rsquo;s call the constants &ldquo;the weights&rdquo;.</p>

<p>The compiler is a software 1.0 that is able to transpile the equations into a sequence of bytes that will be evaluated by a machine (note that the compiler itself is a machine).</p>

<p>So what is the difference between 1.0 and 2.0? Is it just a matter of language?</p>

<p>No, the major difference is in the art of programming and the use case.</p>

<p>For example:</p>

<p>A programmer <strong>cannot</strong> write an algorithm that will <strong>solve a specific problem</strong> (ex: I need to recognize a cat on any photo).</p>

<p>So, the programmer will write a set of equations <strong>able to solve a kind of problem</strong> (recognize objects on any photo).</p>

<p>The solution to the specific problem will be given by the evaluation of the <em>equation</em> <strong>with</strong> <em>its weights</em> (a cat is an object that corresponds to the specific weights: {0,1,3,2,45,6,6,5,3,4,6,&hellip;.}.)</p>

<p>And what makes the software 2.0 so specific? The amount of weights is so important that it cannot be determined manually. They are determined empirically. And a computer is faster than any human in this learning process.</p>

<h1 id="example-of-a-software-2-0-deep-learning">Example of a software 2.0: Deep learning</h1>

<p>Neural networks are the perfect representation of the software 2.0.
In my last <a href="/2017/10/29/about-recurrent-neural-network-shakespeare-and-go.html">blog post</a> I have implemented a recurrent neural network in pure go.</p>

<p>My toy is working, but I have been disappointed by the results: the generated text is poor and repetitive (for example it generates: <code>hello, the the the the the the...</code>). Vanillas RNNs are suffering from the <a href="https://en.wikipedia.org/wiki/Vanishing_gradient_problem">vanishing gradient problem</a> which is most likely the root cause of my problems.</p>

<p>One solution is to change the core model for a more robust network called <strong>L</strong>ong <strong>S</strong>hort <strong>T</strong>erm <strong>M</strong>emory network (LSTM for short).</p>

<p>The software 2.0 will be an implementation of the equations of the LSTM.
Form more information about LSTM, I strongly encourage you to read <a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/">Understanding LSTM Networks</a> from Christopher Olah.</p>

<h2 id="lstm">LSTM</h2>

<p>LSTM are a bit more complex than vanilla RNN. Therefore, a naive go implementation as made for the RNN is harder to code.</p>

<p>As one of my goal is to understand how things deeply works (some articles such as &ldquo;<a href="https://medium.com/@karpathy/yes-you-should-understand-backprop-e2f06eab496b">Yes you should understand backprop</a>&rdquo; makes me confident that it is not a waste of time).</p>

<p>The tricky part of the implementation is in the process called backpropagation.
I have tried to implement the back propagation mechanism manually without any luck.
I have search the web for an algorithm. The best explanation I have found so far is in the <a href="http://cs231n.github.io/optimization-2/">cs231n course from Stanford</a>.
It is a clear explanation of how the process works. And it is obvious that the graph representation helps a lot in the computation of the gradient.</p>

<h2 id="equations-are-graphs">Equations are graphs</h2>

<p>So equations are graphs&hellip;</p>

<p>This <a href="http://gopherdata.io/post/deeplearning_in_go_part_1/">post</a> from <a href="https://twitter.com/chewxy">Chewxy</a> is a perfect illustration of how the expression of a mathematical expression is turned into a graph at a compiler level.</p>

<p>So my software 1.0 must be made of graphs.</p>

<h1 id="writing-the-machinery-software-1-0">Writing the machinery: software 1.0</h1>

<p>Machine learning is usually about graphs and tensors. It exists some optimized library to transpile the equations into graphs. Tensorflow is one of those.
Tensorflow is highly optimized, but the setup of the working environment may be tricky from times to time. As of today, it is not a good candidate for my <em>skynet robot</em> :).</p>

<h2 id="gorgonia">Gorgonia</h2>

<p>Chewxy, the author of the post about equation, is the author of the Gorgonia project.</p>

<blockquote>
<p>Package gorgonia is a library that helps facilitate machine learning in Go. Write and evaluate mathematical equations involving multidimensional arrays easily. Do differentiation with them just as easily.</p>
</blockquote>

<p>This is exactly the answer to my problem.</p>

<p>I have talked to Chewxy on the channel #data-science on #slack. He is really committed, and very active. On top of that I am really attracted by the idea of such a library in go.
I have decided to give gorgonia a try.</p>

<h3 id="machines-graphs-nodes-values-and-backends">Machines, Graphs, Nodes, Values and Backends</h3>

<p>In gorgonia an equation is represented by an <a href="https://godoc.org/github.com/gorgonia/gorgonia#ExprGraph"><code>ExprGraph</code></a>. It is the main entry point of Gorgonia.
A graph is composed of <a href="https://godoc.org/github.com/gorgonia/gorgonia#Node"><code>Nodes</code></a>.
A node is any element in the graph. It is a placeholder that will host a <a href="https://godoc.org/github.com/gorgonia/gorgonia#Value"><code>Value</code></a>.</p>

<p>A <code>Value</code> is an interface. A <a href="https://godoc.org/gorgonia.org/tensor#Tensor"><code>Tensor</code></a> is a type of <code>Value</code>.</p>

<p><code>Tensors</code> are multidimensional arrays that contains elements of the same <a href="https://godoc.org/gorgonia.org/tensor#Dtype"><code>Dtype</code></a>. All those elements are stored in concrete arrays of elements (for example <code>[]float32</code>).</p>

<p>To actually compute the graph, Gorgonia is using &ldquo;a machine&rdquo;:</p>

<ul>
<li>a <a href="https://godoc.org/gorgonia.org/gorgonia#NewLispMachine"><code>lispMachine</code></a> or</li>
<li>a <a href="https://godoc.org/gorgonia.org/gorgonia#NewTapeMachine"><code>tapeMachine</code></a></li>
</ul>

<h4 id="building-a-graph">Building a graph</h4>

<p>To transform a mathematical equation into a graph, we first need to create a graph, then create the Values, assign them to some nodes and add the nodes to the graph.</p>

<p>For example, this equation:</p>

<p>$$z = W \cdot x$$
With
$$W = \begin{bmatrix}0.95 &amp; 0,8 \\ 0 &amp; 0\end{bmatrix}, x = \begin{bmatrix}1 \\ 1\end{bmatrix}$$</p>

<p>Is written like this in &ldquo;gorgonia&rdquo;:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Create a graph
</span><span class="c1"></span><span class="nx">g</span> <span class="o">:=</span> <span class="nx">G</span><span class="p">.</span><span class="nx">NewGraph</span><span class="p">()</span>

<span class="c1">// Create the backend with the inputs
</span><span class="c1"></span><span class="nx">vecB</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">float32</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">}</span>
<span class="c1">// Create the tensor and specify its shape
</span><span class="c1"></span><span class="nx">vecT</span> <span class="o">:=</span> <span class="nx">tensor</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="nx">tensor</span><span class="p">.</span><span class="nx">WithBacking</span><span class="p">(</span><span class="nx">vecB</span><span class="p">),</span> <span class="nx">tensor</span><span class="p">.</span><span class="nx">WithShape</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="c1">// Create a node of type &#34;vector&#34;
</span><span class="c1"></span><span class="nx">vec</span> <span class="o">:=</span> <span class="nx">G</span><span class="p">.</span><span class="nx">NewVector</span><span class="p">(</span><span class="nx">g</span><span class="p">,</span>
        <span class="nx">tensor</span><span class="p">.</span><span class="nx">Float32</span><span class="p">,</span>    <span class="c1">// The type of the data encapsulated within the node
</span><span class="c1"></span>        <span class="nx">G</span><span class="p">.</span><span class="nx">WithName</span><span class="p">(</span><span class="s">&#34;x&#34;</span><span class="p">),</span>   <span class="c1">// The name of the node (optional)
</span><span class="c1"></span>        <span class="nx">G</span><span class="p">.</span><span class="nx">WithShape</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>    <span class="c1">// The shape of the Vector
</span><span class="c1"></span>        <span class="nx">G</span><span class="p">.</span><span class="nx">WithValue</span><span class="p">(</span><span class="nx">vecT</span><span class="p">),</span> <span class="c1">// The value of the node
</span><span class="c1"></span><span class="p">)</span>
<span class="nx">matB</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">float32</span><span class="p">{</span><span class="mf">0.95</span><span class="p">,</span><span class="mf">0.8</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">}</span>
<span class="nx">matT</span> <span class="o">:=</span> <span class="nx">tensor</span><span class="p">.</span><span class="nx">New</span><span class="p">(</span><span class="nx">tensor</span><span class="p">.</span><span class="nx">WithBacking</span><span class="p">(</span><span class="nx">matB</span><span class="p">),</span> <span class="nx">tensor</span><span class="p">.</span><span class="nx">WithShape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="nx">mat</span> <span class="o">:=</span> <span class="nx">G</span><span class="p">.</span><span class="nx">NewMatrix</span><span class="p">(</span><span class="nx">g</span><span class="p">,</span> 
        <span class="nx">tensor</span><span class="p">.</span><span class="nx">Float32</span><span class="p">,</span> 
        <span class="nx">G</span><span class="p">.</span><span class="nx">WithName</span><span class="p">(</span><span class="s">&#34;W&#34;</span><span class="p">),</span> 
        <span class="nx">G</span><span class="p">.</span><span class="nx">WithShape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> 
        <span class="nx">G</span><span class="p">.</span><span class="nx">WithValue</span><span class="p">(</span><span class="nx">matT</span><span class="p">),</span>
<span class="p">)</span>

<span class="c1">// z is a new node of the graph &#34;g&#34;.
</span><span class="c1">// It does not contains the actual result because the graph
</span><span class="c1">// has not be computed yet
</span><span class="c1"></span><span class="nx">z</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">G</span><span class="p">.</span><span class="nx">Mul</span><span class="p">(</span><span class="nx">mat</span><span class="p">,</span> <span class="nx">vec</span><span class="p">)</span>
<span class="c1">// ... error handling
</span><span class="c1"></span>
<span class="c1">// create a VM to run the program on
</span><span class="c1"></span><span class="nx">machine</span> <span class="o">:=</span> <span class="nx">G</span><span class="p">.</span><span class="nx">NewTapeMachine</span><span class="p">(</span><span class="nx">g</span><span class="p">)</span>

<span class="c1">// The graph is executed now !
</span><span class="c1"></span><span class="nx">err</span> <span class="p">=</span> <span class="nx">machine</span><span class="p">.</span><span class="nx">RunAll</span><span class="p">()</span>
<span class="c1">// ... error handling
</span><span class="c1">// Now we can print the value of z
</span><span class="c1"></span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">z</span><span class="p">.</span><span class="nx">Value</span><span class="p">().</span><span class="nx">Data</span><span class="p">())</span>
<span class="o">//</span> <span class="nx">will</span> <span class="nx">display</span> <span class="p">[</span><span class="mf">1.75</span> <span class="mi">0</span><span class="p">]</span> <span class="nx">which</span> <span class="nx">is</span> <span class="nx">a</span> <span class="p">[]</span><span class="kt">float32</span><span class="p">{}</span></code></pre></div>
<p>The problem is:</p>

<p>The more complex the model is, the more verbose the code will be, the harder to debug.
For example, a LSTM with a forget gate is expressed like this:</p>

<p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/2db2cba6a0d878e13932fa27ce6f3fb71ad99cf1" alt="Wikipedia" /></p>

<p>Source:   <a href="https://en.wikipedia.org/wiki/Long_short-term_memory">wikipedia</a></p>

<p>Transpiling it with gorgonia will lead to something like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">h0</span><span class="p">,</span> <span class="nx">h1</span><span class="p">,</span> <span class="nx">inputGate</span> <span class="o">*</span><span class="nx">Node</span>
<span class="nx">h0</span> <span class="p">=</span> <span class="nx">Must</span><span class="p">(</span><span class="nx">Mul</span><span class="p">(</span><span class="nx">l</span><span class="p">.</span><span class="nx">wix</span><span class="p">,</span> <span class="nx">inputVector</span><span class="p">))</span>
<span class="nx">h1</span> <span class="p">=</span> <span class="nx">Must</span><span class="p">(</span><span class="nx">Mul</span><span class="p">(</span><span class="nx">l</span><span class="p">.</span><span class="nx">wih</span><span class="p">,</span> <span class="nx">prevHidden</span><span class="p">))</span>
<span class="nx">inputGate</span> <span class="p">=</span> <span class="nx">Must</span><span class="p">(</span><span class="nx">Sigmoid</span><span class="p">(</span><span class="nx">Must</span><span class="p">(</span><span class="nx">Add</span><span class="p">(</span><span class="nx">Must</span><span class="p">(</span><span class="nx">Add</span><span class="p">(</span><span class="nx">h0</span><span class="p">,</span> <span class="nx">h1</span><span class="p">)),</span> <span class="nx">l</span><span class="p">.</span><span class="nx">bias_i</span><span class="p">))))</span>

<span class="kd">var</span> <span class="nx">h2</span><span class="p">,</span> <span class="nx">h3</span><span class="p">,</span> <span class="nx">forgetGate</span> <span class="o">*</span><span class="nx">Node</span>
<span class="nx">h2</span> <span class="p">=</span> <span class="nx">Must</span><span class="p">(</span><span class="nx">Mul</span><span class="p">(</span><span class="nx">l</span><span class="p">.</span><span class="nx">wfx</span><span class="p">,</span> <span class="nx">inputVector</span><span class="p">))</span>
<span class="nx">h3</span> <span class="p">=</span> <span class="nx">Must</span><span class="p">(</span><span class="nx">Mul</span><span class="p">(</span><span class="nx">l</span><span class="p">.</span><span class="nx">wfh</span><span class="p">,</span> <span class="nx">prevHidden</span><span class="p">))</span>
<span class="nx">forgetGate</span> <span class="p">=</span> <span class="nx">Must</span><span class="p">(</span><span class="nx">Sigmoid</span><span class="p">(</span><span class="nx">Must</span><span class="p">(</span><span class="nx">Add</span><span class="p">(</span><span class="nx">Must</span><span class="p">(</span><span class="nx">Add</span><span class="p">(</span><span class="nx">h2</span><span class="p">,</span> <span class="nx">h3</span><span class="p">)),</span> <span class="nx">l</span><span class="p">.</span><span class="nx">bias_f</span><span class="p">))))</span>

<span class="kd">var</span> <span class="nx">h4</span><span class="p">,</span> <span class="nx">h5</span><span class="p">,</span> <span class="nx">outputGate</span> <span class="o">*</span><span class="nx">Node</span>
<span class="nx">h4</span> <span class="p">=</span> <span class="nx">Must</span><span class="p">(</span><span class="nx">Mul</span><span class="p">(</span><span class="nx">l</span><span class="p">.</span><span class="nx">wox</span><span class="p">,</span> <span class="nx">inputVector</span><span class="p">))</span>
<span class="nx">h5</span> <span class="p">=</span> <span class="nx">Must</span><span class="p">(</span><span class="nx">Mul</span><span class="p">(</span><span class="nx">l</span><span class="p">.</span><span class="nx">woh</span><span class="p">,</span> <span class="nx">prevHidden</span><span class="p">))</span>
<span class="nx">outputGate</span> <span class="p">=</span> <span class="nx">Must</span><span class="p">(</span><span class="nx">Sigmoid</span><span class="p">(</span><span class="nx">Must</span><span class="p">(</span><span class="nx">Add</span><span class="p">(</span><span class="nx">Must</span><span class="p">(</span><span class="nx">Add</span><span class="p">(</span><span class="nx">h4</span><span class="p">,</span> <span class="nx">h5</span><span class="p">)),</span> <span class="nx">l</span><span class="p">.</span><span class="nx">bias_o</span><span class="p">))))</span>

<span class="kd">var</span> <span class="nx">h6</span><span class="p">,</span> <span class="nx">h7</span><span class="p">,</span> <span class="nx">cellWrite</span> <span class="o">*</span><span class="nx">Node</span>
<span class="nx">h6</span> <span class="p">=</span> <span class="nx">Must</span><span class="p">(</span><span class="nx">Mul</span><span class="p">(</span><span class="nx">l</span><span class="p">.</span><span class="nx">wcx</span><span class="p">,</span> <span class="nx">inputVector</span><span class="p">))</span>
<span class="nx">h7</span> <span class="p">=</span> <span class="nx">Must</span><span class="p">(</span><span class="nx">Mul</span><span class="p">(</span><span class="nx">l</span><span class="p">.</span><span class="nx">wch</span><span class="p">,</span> <span class="nx">prevHidden</span><span class="p">))</span>
<span class="nx">cellWrite</span> <span class="p">=</span> <span class="nx">Must</span><span class="p">(</span><span class="nx">Tanh</span><span class="p">(</span><span class="nx">Must</span><span class="p">(</span><span class="nx">Add</span><span class="p">(</span><span class="nx">Must</span><span class="p">(</span><span class="nx">Add</span><span class="p">(</span><span class="nx">h6</span><span class="p">,</span> <span class="nx">h7</span><span class="p">)),</span> <span class="nx">l</span><span class="p">.</span><span class="nx">bias_c</span><span class="p">))))</span>

<span class="c1">// cell activations
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">retain</span><span class="p">,</span> <span class="nx">write</span> <span class="o">*</span><span class="nx">Node</span>
<span class="nx">retain</span> <span class="p">=</span> <span class="nx">Must</span><span class="p">(</span><span class="nx">HadamardProd</span><span class="p">(</span><span class="nx">forgetGate</span><span class="p">,</span> <span class="nx">prevCell</span><span class="p">))</span>
<span class="nx">write</span> <span class="p">=</span> <span class="nx">Must</span><span class="p">(</span><span class="nx">HadamardProd</span><span class="p">(</span><span class="nx">inputGate</span><span class="p">,</span> <span class="nx">cellWrite</span><span class="p">))</span>
<span class="nx">cell</span> <span class="p">=</span> <span class="nx">Must</span><span class="p">(</span><span class="nx">Add</span><span class="p">(</span><span class="nx">retain</span><span class="p">,</span> <span class="nx">write</span><span class="p">))</span>
<span class="nx">hidden</span> <span class="p">=</span> <span class="nx">Must</span><span class="p">(</span><span class="nx">HadamardProd</span><span class="p">(</span><span class="nx">outputGate</span><span class="p">,</span> <span class="nx">Must</span><span class="p">(</span><span class="nx">Tanh</span><span class="p">(</span><span class="nx">cell</span><span class="p">))))</span></code></pre></div>
<p>Actually the concept is close to the Reverse Polish Notation. But what would make my life easier would be to process the equation written as-is in unicode:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">set</span><span class="p">(</span><span class="s">`iₜ`</span><span class="p">,</span> <span class="s">`σ(Wᵢ·xₜ+Uᵢ·hₜ₋₁+Bᵢ)`</span><span class="p">)</span>
<span class="nx">set</span><span class="p">(</span><span class="s">`fₜ`</span><span class="p">,</span> <span class="s">`σ(Wf·xₜ+Uf·hₜ₋₁+Bf)`</span><span class="p">)</span> 
<span class="nx">set</span><span class="p">(</span><span class="s">`oₜ`</span><span class="p">,</span> <span class="s">`σ(Wₒ·xₜ+Uₒ·hₜ₋₁+Bₒ)`</span><span class="p">)</span>
<span class="nx">set</span><span class="p">(</span><span class="s">`ĉₜ`</span><span class="p">,</span> <span class="s">`tanh(Wc·xₜ+Uc·hₜ₋₁+Bc)`</span><span class="p">)</span> 
<span class="nx">ct</span> <span class="o">:=</span> <span class="nx">set</span><span class="p">(</span><span class="s">`cₜ`</span><span class="p">,</span> <span class="s">`fₜ*cₜ₋₁+iₜ*ĉₜ`</span><span class="p">)</span>
<span class="nx">set</span><span class="p">(</span><span class="s">`hc`</span><span class="p">,</span> <span class="s">`tanh(cₜ)`</span><span class="p">)</span>
<span class="nx">ht</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">parser</span><span class="p">.</span><span class="nx">Parse</span><span class="p">(</span><span class="s">`oₜ*hc`</span><span class="p">)</span></code></pre></div>
<p><em>Note</em> If you don&rsquo;t have the correct font to display the unicode character click <a href="/assets/lstm/uni-code.png">here</a></p>

<h2 id="good-ol-software-1-0">Good ol&rsquo; software 1.0</h2>

<p>What I will do is to write a lexer and a parser to analyze the mathematical equations written in unicode and generate the corresponding gorgonia execution graph.</p>

<h3 id="lexer-parser">Lexer/Parser</h3>

<p>My first attempt was to use a simple lexer and a simple parser. This is described in many posts over the internet all based on a talk by Rob Pike: <a href="https://talks.golang.org/2011/lex.slide#1">Lexical Scanning in GO</a>.
I have been able to write the lexer easily.
The parser was more difficult to write because of the mathematical <a href="https://en.wikipedia.org/wiki/Order_of_operations">operator precedence</a>.</p>

<p>After a bunch of documentation about LALR parser, I have decided to call an old friend: <em>yacc</em></p>

<p><center><br />
<blockquote class="twitter-tweet"><p lang="en" dir="ltr">dude you sound so quadragenarian!</p>&mdash; Pierre (@p_grandin) <a href="https://twitter.com/p_grandin/status/941817771863584768?ref_src=twsrc%5Etfw">December 15, 2017</a></blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

</center></p>

<p>In the world of go, there is <a href="https://godoc.org/golang.org/x/tools/cmd/goyacc">goyacc</a> whose syntax is compatible with yacc, but which generates parsers written in go.
I have found a perfect example of a calculator <a href="https://github.com/golang/tools/tree/master/cmd/goyacc/testdata/expr">here</a></p>

<h3 id="the-grammar">The grammar</h3>

<p>The token that I will recognize are the basic matrix operations I need for my LSTM, plus the sigmoid and the tanh function:</p>

<pre><code>%token '+' '·' '-' '*' '/' '(' ')' '=' 'σ' tanh
</code></pre>

<p>the <code>yylval</code> are always pointer to Gorgonia nodes</p>

<pre><code>%union {
        node *G.Node
}

%token  &lt;node&gt;  NODE
</code></pre>

<p>The grammar and the application of the operators are all described in a couple of lines. For example, addition and multiplications are described like this:</p>

<pre><code>...
expr1:
        expr2
|       expr1 '+' expr2
        {
                $$ = G.Must(G.Add($1,$3))
        }
|       expr1 '-' expr2
        {
                $$ = G.Must(G.Sub($1,$3))
        }

expr2:
        expr3
|       expr2 '·' expr3
        {
                $$ = G.Must(G.Mul($1,$3))
        }
|       expr2 '*' expr3
        {
                $$ = G.Must(G.HadamardProd($1,$3))
                        }
|       expr2 '/' expr3
        {
                $$ = G.Must(G.Div($1,$3))
        }
...
</code></pre>

<p>You can find the complete file <a href="https://raw.githubusercontent.com/owulveryck/charRNN/colah/parser/src/expr.y">here</a>.</p>

<h3 id="the-parser-and-the-lexer">The parser and the lexer</h3>

<p>The lexer implementation is a struct type that fullfills the interface</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">yyLexer</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nx">Lex</span><span class="p">(</span><span class="nx">lval</span> <span class="o">*</span><span class="nx">yySymType</span><span class="p">)</span> <span class="kt">int</span>
	<span class="nx">Error</span><span class="p">(</span><span class="nx">e</span> <span class="kt">string</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<p>The Lexer will read elements such as <code>Wₜ</code>, but will not know how to associate it with the pointer to Gorgonia.Node.
My lexer must be aware of a correspondence between a unicode representation and the go expression.
For this purpose, I add a dictionary of elements. It is a map whose key is the representation and the value is the pointer to the node:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">exprLex</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">line</span> <span class="p">[]</span><span class="kt">byte</span>
	<span class="nx">peek</span> <span class="kt">rune</span>
        <span class="nx">dico</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">G</span><span class="p">.</span><span class="nx">Node</span> <span class="c1">// dictionary
</span><span class="c1"></span>	<span class="nx">g</span>      <span class="o">*</span><span class="nx">G</span><span class="p">.</span><span class="nx">ExprGraph</span>
        <span class="nx">result</span> <span class="o">*</span><span class="nx">G</span><span class="p">.</span><span class="nx">Node</span>
        <span class="nx">err</span> <span class="kt">error</span>
<span class="p">}</span></code></pre></div>
<p>I also add a method <code>Let</code> that sets an entry in the dictionary.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="o">*</span><span class="nx">exprLex</span><span class="p">)</span> <span class="nx">Let</span><span class="p">(</span><span class="nx">ident</span>  <span class="kt">string</span><span class="p">,</span> <span class="nx">value</span> <span class="o">*</span><span class="nx">G</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">x</span><span class="p">.</span><span class="nx">dico</span><span class="p">[</span><span class="nx">ident</span><span class="p">]</span> <span class="p">=</span> <span class="nx">value</span>
<span class="p">}</span></code></pre></div>
<p>I will not describe the rest of the file because the implementation is straightforward and easy to read.</p>

<h3 id="generating-the-package">Generating the package</h3>

<p>The yacc tools actually generates a parser in go. I have chosen to declare it in its own package.
The command <code>goyacc -o ../expr.go -p &quot;gorgonia&quot; expr.y</code> will generate the file <code>expr.go</code> which holds an implementation able to parse my unicode equations.</p>

<p>I have also added a couple of helpers function to avoid public methods. My API is therefore simple:</p>

<pre><code>type Parser
    func NewParser(g *G.ExprGraph) *Parser
    func (p *Parser) Parse(s string) (*G.Node, error)
    func (p *Parser) Set(ident string, value *G.Node)
</code></pre>

<p>(see <a href="https://godoc.org/github.com/owulveryck/charRNN/parser">godoc</a> for more details).</p>

<h1 id="does-it-work">Does it work ?</h1>

<p>With my parser, I am able to write a LSTM step easily and to generate an execution graph:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">lstm</span><span class="p">)</span> <span class="nx">fwd</span><span class="p">(</span><span class="nx">inputVector</span><span class="p">,</span> <span class="nx">prevHidden</span><span class="p">,</span> <span class="nx">prevCell</span> <span class="o">*</span><span class="nx">G</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="p">(</span><span class="nx">hidden</span><span class="p">,</span> <span class="nx">cell</span> <span class="o">*</span><span class="nx">G</span><span class="p">.</span><span class="nx">Node</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Helper function for clarity
</span><span class="c1"></span>	<span class="nx">set</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ident</span><span class="p">,</span> <span class="nx">equation</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">G</span><span class="p">.</span><span class="nx">Node</span> <span class="p">{</span>
		<span class="nx">res</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">parser</span><span class="p">.</span><span class="nx">Parse</span><span class="p">(</span><span class="nx">equation</span><span class="p">)</span>
		<span class="nx">l</span><span class="p">.</span><span class="nx">parser</span><span class="p">.</span><span class="nx">Set</span><span class="p">(</span><span class="nx">ident</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span>
		<span class="k">return</span> <span class="nx">res</span>
	<span class="p">}</span>

	<span class="nx">l</span><span class="p">.</span><span class="nx">parser</span><span class="p">.</span><span class="nx">Set</span><span class="p">(</span><span class="s">`xₜ`</span><span class="p">,</span> <span class="nx">inputVector</span><span class="p">)</span>
	<span class="nx">l</span><span class="p">.</span><span class="nx">parser</span><span class="p">.</span><span class="nx">Set</span><span class="p">(</span><span class="s">`hₜ₋₁`</span><span class="p">,</span> <span class="nx">prevHidden</span><span class="p">)</span>
	<span class="nx">l</span><span class="p">.</span><span class="nx">parser</span><span class="p">.</span><span class="nx">Set</span><span class="p">(</span><span class="s">`cₜ₋₁`</span><span class="p">,</span> <span class="nx">prevCell</span><span class="p">)</span>
	<span class="nx">set</span><span class="p">(</span><span class="s">`iₜ`</span><span class="p">,</span> <span class="s">`σ(Wᵢ·xₜ+Uᵢ·hₜ₋₁+Bᵢ)`</span><span class="p">)</span>
	<span class="nx">set</span><span class="p">(</span><span class="s">`fₜ`</span><span class="p">,</span> <span class="s">`σ(Wf·xₜ+Uf·hₜ₋₁+Bf)`</span><span class="p">)</span> <span class="c1">// dot product made with ctrl+k . M
</span><span class="c1"></span>	<span class="nx">set</span><span class="p">(</span><span class="s">`oₜ`</span><span class="p">,</span> <span class="s">`σ(Wₒ·xₜ+Uₒ·hₜ₋₁+Bₒ)`</span><span class="p">)</span>
	<span class="c1">// ċₜis a vector of new candidates value
</span><span class="c1"></span>	<span class="nx">set</span><span class="p">(</span><span class="s">`ĉₜ`</span><span class="p">,</span> <span class="s">`tanh(Wc·xₜ+Uc·hₜ₋₁+Bc)`</span><span class="p">)</span> <span class="c1">// c made with ctrl+k c &gt;
</span><span class="c1"></span>	<span class="nx">ct</span> <span class="o">:=</span> <span class="nx">set</span><span class="p">(</span><span class="s">`cₜ`</span><span class="p">,</span> <span class="s">`fₜ*cₜ₋₁+iₜ*ĉₜ`</span><span class="p">)</span>
	<span class="nx">set</span><span class="p">(</span><span class="s">`hc`</span><span class="p">,</span> <span class="s">`tanh(cₜ)`</span><span class="p">)</span>
	<span class="nx">ht</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">parser</span><span class="p">.</span><span class="nx">Parse</span><span class="p">(</span><span class="s">`oₜ*hc`</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">ht</span><span class="p">,</span> <span class="nx">ct</span>
<span class="p">}</span></code></pre></div>
<p>which leads to:</p>

<p><img src="/assets/lstm/LSTM.png" alt="image" />
Now I will be able to work deeply on the software 2.0 part.</p>

<h1 id="conclusion">Conclusion</h1>

<p>As Karpathy&rsquo;s explained: we will still need software 1.0 to build software 2.0. I have used very old concepts to build some tools for writing and processing a software 2.0.
In my example, the software 2.0 is the combination of the equations written in unicode and the values of the tensors which are arrays of floats.</p>

<p>A better step would be to parse a complete set of equations such as:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">parse</span><span class="p">(</span><span class="s">`
</span><span class="s">iₜ=σ(Wᵢ·xₜ+Uᵢ·hₜ₋₁+Bᵢ)
</span><span class="s">fₜ=σ(Wf·xₜ+Uf·hₜ₋₁+Bf)
</span><span class="s">oₜ=σ(Wₒ·xₜ+Uₒ·hₜ₋₁+Bₒ)
</span><span class="s">ĉₜ=tanh(Wc·xₜ+Uc·hₜ₋₁+Bc)
</span><span class="s">cₜ=fₜ*cₜ₋₁+iₜ*ĉ
</span><span class="s">hₜ=oₜ*tanh(cₜ)
</span><span class="s">`</span><span class="p">)</span></code></pre></div>
<p>The software 2.0, once trained, can be backed up as a unicode text file and a couple of floating point numbers.
It would then be independent of the execution machine. A parser could transpile it into a gorgonia execution graph, or a tensorflow execution graph, &hellip;</p>

<p>A true and independent software 2.0.</p>

<blockquote>
<p><em>“A journey of a thousand miles must begin with a single step.”</em> – <em>Lao Tzu</em></p>
</blockquote>


  
  
  <hr>
<footer>
  <header>
    <h4>Share</h4>
  </header>
  <nav class="nav nav-inline">
    <a class="nav-item" href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.owulveryck.info%2f2017%2f12%2f18%2fparsing-mathematical-equation-to-generate-computation-graphs---first-step-from-software-1.0-to-2.0-in-go.html" title="Share on Facebook"><span class="fa fa-facebook fa-2x" aria-hidden="true"></span></a>
    <a class="nav-item" href="https://plus.google.com/share?url=https%3a%2f%2fblog.owulveryck.info%2f2017%2f12%2f18%2fparsing-mathematical-equation-to-generate-computation-graphs---first-step-from-software-1.0-to-2.0-in-go.html" title="Share on Google+"><span class="fa fa-google-plus fa-2x" aria-hidden="true"></span></a>
    <a class="nav-item" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fblog.owulveryck.info%2f2017%2f12%2f18%2fparsing-mathematical-equation-to-generate-computation-graphs---first-step-from-software-1.0-to-2.0-in-go.html" title="Share on LinkedIn"><span class="fa fa-linkedin fa-2x" aria-hidden="true"></span></a>
    <a class="nav-item" href="https://twitter.com/home?status=https%3a%2f%2fblog.owulveryck.info%2f2017%2f12%2f18%2fparsing-mathematical-equation-to-generate-computation-graphs---first-step-from-software-1.0-to-2.0-in-go.html" title="Tweet this"><span class="fa fa-twitter fa-2x"></span></a>
  </nav>
</footer>

  
</article> 



<div id="disqus_thread"></div>
<script type="text/javascript">

(function() {
  
  
  if (window.location.hostname == "localhost")
    return;

  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  var disqus_shortname = 'owulveryck';
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>





        </div> <!-- /.blog-main -->

        <aside class="col-sm-3 offset-sm-1 blog-sidebar">
  
  <section class="sidebar-module sidebar-module-inset">
    <h4>About</h4>
    <p>This is a place where I share my technical experiences alongside my life of IT professional<br> Because even finding the air-speed velocity of an unladen swallow can be fun.<br><br> <strong>Sir Bedevere</strong>: <em>How do know so much about swallows?</em><br><strong>King Arthur</strong>: <em>Well, you have to know these things when you&rsquo;re a king, you know.</em><br><br><em>Monty Python and the Holy Grail</em></p>
  </section>
  

  

  <section class="sidebar-module">
    <h4>Recent Posts</h4>
    <ol class="list-unstyled">
      
      <li><a href="/2017/12/18/parsing-mathematical-equation-to-generate-computation-graphs---first-step-from-software-1.0-to-2.0-in-go.html">Parsing mathematical equation to generate computation graphs - First step from software 1.0 to 2.0 in go</a></li>
      <hr>
      
      <li><a href="/2017/10/29/about-recurrent-neural-network-shakespeare-and-go.html">About Recurrent Neural Network, Shakespeare and GO</a></li>
      <hr>
      
      <li><a href="/2017/09/12/terraform-is-hip...-introducing-nhite.html">Terraform is hip&hellip; Introducing Nhite</a></li>
      <hr>
      
      <li><a href="/2017/09/02/from-command-line-tools-to-microservices---the-example-of-hashicorp-tools-terraform-and-grpc.html">From command line tools to microservices - The example of Hashicorp tools (terraform) and gRPC</a></li>
      <hr>
      
      <li><a href="/2017/08/14/when-i-apply-a-350-update-on-the-iphone.html">When I apply a 350€ update on the iPhone</a></li>
      <hr>
      
    </ol>
  </section>

  
</aside>


      </div> <!-- /.row -->
    </div> <!-- /.container -->

    <footer class="blog-footer">
      <p>
      
      All rights reserved - <sup>2015</sup>&frasl;<sub>2017</sub>
      
      </p>
      <p>
      <a href="#">Back to top</a>
      </p>
    </footer>

  </body>

</html>
