<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ruby on Olivier Wulveryck&#39;s Tech Blog</title>
    <link>http://blog.owulveryck.info/tags/ruby/</link>
    <description>Recent content in Ruby on Olivier Wulveryck&#39;s Tech Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>olivier.wulveryck@gmail.com (Olivier Wulveryck)</managingEditor>
    <webMaster>olivier.wulveryck@gmail.com (Olivier Wulveryck)</webMaster>
    <copyright>All rights reserved - 2015</copyright>
    <lastBuildDate>Tue, 10 Nov 2015 08:56:36 +0100</lastBuildDate>
    <atom:link href="http://blog.owulveryck.info/tags/ruby/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>IaaS-like RESTfull API based on microservices</title>
      <link>http://blog.owulveryck.info/2015/11/10/iaas-like-restfull-api-based-on-microservices/</link>
      <pubDate>Tue, 10 Nov 2015 08:56:36 +0100</pubDate>
      <author>olivier.wulveryck@gmail.com (Olivier Wulveryck)</author>
      <guid>http://blog.owulveryck.info/2015/11/10/iaas-like-restfull-api-based-on-microservices/</guid>
      <description>

&lt;h1 id=&#34;abstracts:1574d51e403296c43e921da78612bc7c&#34;&gt;Abstracts&lt;/h1&gt;

&lt;p&gt;Recently, I&amp;rsquo;ve been looking at the principles of a middleware layer and especially on how a RESTFULL API could glue different IT services together.&lt;/p&gt;

&lt;p&gt;I am reading more and more about the &amp;ldquo;API economy&amp;rdquo;&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve also seen this excellent video made by &lt;a href=&#34;https://www.youtube.com/watch?v=tIm8UkSf6RA&amp;amp;list=PLDWZ5uzn69ezRJYeWxYNRMYebvf8DerHd&#34;&gt;Mat Ryer&lt;/a&gt; about how to code an API in GO and why go would be the perfect language to code such a portal.&lt;/p&gt;

&lt;p&gt;The problem I&amp;rsquo;m facing is that in the organization I&amp;rsquo;m working for, the developments are heterogeneous and therefore you can find &lt;em&gt;ruby&lt;/em&gt; teams as well as &lt;em&gt;python&lt;/em&gt; teams and myself as a &lt;em&gt;go&lt;/em&gt; team (That will change in the future anyway)
The key point is that I would like my middleware to serve as an entry point to the services provided by the department.&lt;/p&gt;

&lt;p&gt;We (as an &amp;ldquo;ops&amp;rdquo; team) would then be able to present the interface via, for example, a &lt;a href=&#34;http://swagger.io&#34;&gt;swagger&lt;/a&gt; like interface, take care of the API and do whatever RPC to any submodule.&lt;/p&gt;

&lt;h1 id=&#34;an-example-a-iaas-like-interface:1574d51e403296c43e921da78612bc7c&#34;&gt;An example: a IAAS like interface&lt;/h1&gt;

&lt;p&gt;Let&amp;rsquo;s consider a node compute lifecycle.&lt;/p&gt;

&lt;p&gt;What I&amp;rsquo;d like to be able to do is:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;to create a node&lt;/li&gt;
&lt;li&gt;to update a node (maybe)&lt;/li&gt;
&lt;li&gt;to delete a node&lt;/li&gt;
&lt;li&gt;to get the status of the node&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;the-backend:1574d51e403296c43e921da78612bc7c&#34;&gt;The backend&lt;/h2&gt;

&lt;p&gt;The backend is whatever service, able to create a node, such as openstack, vmware vcac, juju, &amp;hellip;
Thoses services usually provide RESTfull API.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve seen in my experience, that usually, the API are given with a library in a so called &amp;ldquo;modern language&amp;rdquo;.
This aim to simplify the development of the clients.
Sometimes this library may also be developed by an internal team that will take care of the maintenance.&lt;/p&gt;

&lt;h2 id=&#34;the-library:1574d51e403296c43e921da78612bc7c&#34;&gt;The library&lt;/h2&gt;

&lt;p&gt;In my example, we will consider that the library is a simple &lt;em&gt;gem&lt;/em&gt; file developed in ruby.
Therefore, our service will be a simple server that will get RPC calls, call the good method in the &lt;em&gt;gemfile&lt;/em&gt;
and that will, &lt;em&gt;in fine&lt;/em&gt; transfer it to the backend.&lt;/p&gt;

&lt;h2 id=&#34;the-restfull-api:1574d51e403296c43e921da78612bc7c&#34;&gt;The RestFull API.&lt;/h2&gt;

&lt;p&gt;I will use the example described &lt;a href=&#34;http://thenewstack.io/make-a-restful-json-api-go/&#34;&gt;here&lt;/a&gt; as a basis for this post.
Of course there are many other examples and excellent go packages that may be used, but according to Mat Ryer, I will stick to the idiomatic approach.&lt;/p&gt;

&lt;h2 id=&#34;the-glue-msgpack-rpc:1574d51e403296c43e921da78612bc7c&#34;&gt;The glue: MSGPACK-RPC&lt;/h2&gt;

&lt;p&gt;There are several methods for RPC-ing between different languages. Ages ago, there was xml-rpc; then there has been json-rpc;
I will use &lt;a href=&#34;https://github.com/msgpack-rpc/msgpack-rpc&#34;&gt;msgpack-rpc&lt;/a&gt; which is a binary, json base codec.
The communication between the Go client and the ruby server will be done over TCP via HTTP for example.&lt;/p&gt;

&lt;p&gt;Later on, outside of the scope of this post, I may use ZMQ (as I have already blogged about 0MQ communication between those languages).&lt;/p&gt;

&lt;h1 id=&#34;the-implementation-of-the-client-the-go-part:1574d51e403296c43e921da78612bc7c&#34;&gt;The implementation of the Client (the go part)&lt;/h1&gt;

&lt;p&gt;I will describe here the node creation via a POST method, and consider that the other methods could be implemented in a similar way.&lt;/p&gt;

&lt;h2 id=&#34;the-signature-of-the-node-creation:1574d51e403296c43e921da78612bc7c&#34;&gt;The signature of the node creation&lt;/h2&gt;

&lt;p&gt;Here is the expected signature for creating a compute element:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
    &amp;quot;kind&amp;quot;:&amp;quot;linux&amp;quot;,
    &amp;quot;size&amp;quot;:&amp;quot;S&amp;quot;,
    &amp;quot;disksize&amp;quot;:20,
    &amp;quot;leasedays&amp;quot;:1,
    &amp;quot;environment_type&amp;quot;:&amp;quot;dev&amp;quot;,
    &amp;quot;description&amp;quot;:&amp;quot;my_description&amp;quot;,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The corresponding GO structure is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type NodeRequest struct {
    Kind string `json:&amp;quot;kind&amp;quot;` // Node kind (eg linux)
    Size string `json:&amp;quot;size&amp;quot;` // size
    Disksize         int    `json:&amp;quot;disksize&amp;quot;`
    Leasedays        int    `json:&amp;quot;leasedays&amp;quot;`
    EnvironmentType  string `json:&amp;quot;environment_type&amp;quot;`
    Description      string `json:&amp;quot;description&amp;quot;`
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;the-route:1574d51e403296c43e921da78612bc7c&#34;&gt;The route&lt;/h2&gt;

&lt;p&gt;The Middleware is using the &lt;a href=&#34;http://www.gorillatoolkit.org/pkg/mux&#34;&gt;gorilla mux package&lt;/a&gt;.
According the description, I will add an entry in the routes array (into the &lt;em&gt;routes.go&lt;/em&gt; file):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;Route{
    &amp;quot;NodeCreate&amp;quot;,
    &amp;quot;POST&amp;quot;,
    &amp;quot;/v1/nodes&amp;quot;,
    NodeCreate,
},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Note&lt;/em&gt; : I am using a prefix &lt;code&gt;/v1&lt;/code&gt; for my API, for exploitation purpose.&lt;/p&gt;

&lt;p&gt;I will then create the corresponding handler in the file with this signature&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func NodeCreate(w http.ResponseWriter, r *http.Request){
    var nodeRequest NodeRequest
    body, err := ioutil.ReadAll(io.LimitReader(r.Body, 1048576))
    if err != nil {
        panic(err)
    }
    if err := r.Body.Close(); err != nil {
        panic(err)
    }
    if err := json.Unmarshal(body, &amp;amp;nodeRequest); err != nil {
        w.Header().Set(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json; charset=UTF-8&amp;quot;)
        w.WriteHeader(http.StatusBadRequest) // unprocessable entity
        if err := json.NewEncoder(w).Encode(err); err != nil {
            panic(err)
        }
    }    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s in this function that will be implemented RPC (client part). To keep it simple at the beginning,
I will instantiate a TCP connection on every call.
Don&amp;rsquo;t throw things at me, that will be changed later following the advice of Mat Ryer.&lt;/p&gt;

&lt;h2 id=&#34;the-implementation-of-the-handler:1574d51e403296c43e921da78612bc7c&#34;&gt;The implementation of the handler&lt;/h2&gt;

&lt;h3 id=&#34;the-effective-remote-procedure-call:1574d51e403296c43e921da78612bc7c&#34;&gt;The effective remote procedure call&lt;/h3&gt;

&lt;p&gt;To use &lt;em&gt;msgpack&lt;/em&gt; I need to import the go implementation &lt;code&gt;github.com/msgpack-rpc/msgpack-rpc-go/rpc&lt;/code&gt;.
This library will take care of the encoding/decoding of the messages.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s dial the RPC server and call the &lt;code&gt;NodeCreate&lt;/code&gt; method with, as argument, the information we had from the JSON input&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;    conn, err := net.Dial(&amp;quot;tcp&amp;quot;, &amp;quot;127.0.0.1:18800&amp;quot;)
    if err != nil {
        fmt.Println(&amp;quot;fail to connect to server.&amp;quot;)
        return
    }
    client := rpc.NewSession(conn, true)
    retval, err := client.Send(&amp;quot;NodeCreate&amp;quot;, nodeRequest.Kind, nodeRequest.Size, nodeRequest.Disksize, nodeRequest.Leasedays, nodeRequest.EnvironmentType, nodeRequest.Description)
    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Println(retval)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;the-rpc-server-the-ruby-part:1574d51e403296c43e921da78612bc7c&#34;&gt;The RPC server (the ruby part)&lt;/h1&gt;

&lt;p&gt;This part is written in ruby, and will take care of the effective node creation.
At first, we should install the GEM file with the command &lt;code&gt;gem install msgpack-rpc&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &#39;msgpack/rpc&#39;
class MyHandler
    def NodeCreate(kind, size, disksize, leasedays, environmenttype, description) 
        print &amp;quot;Creating the node with parameters: &amp;quot;,kind, size, disksize, leasedays, environmenttype, description
        return &amp;quot;ok&amp;quot;
    end
end
svr = MessagePack::RPC::Server.new
svr.listen(&#39;0.0.0.0&#39;, 18800, MyHandler.new)
svr.run
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;let-s-test-it:1574d51e403296c43e921da78612bc7c&#34;&gt;let&amp;rsquo;s test it&lt;/h1&gt;

&lt;p&gt;Launch the RPC server:
&lt;code&gt;ruby server.rb&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Then launch the API rest server&lt;/p&gt;

&lt;p&gt;&lt;code&gt;go run *go&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Then perform a POST request&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;curl -X POST -H &#39;Content-Type:application/json&#39; -H &#39;Accept:application/json&#39; -d &#39;{&amp;quot;kind&amp;quot;:&amp;quot;linux&amp;quot;,&amp;quot;size&amp;quot;:&amp;quot;S&amp;quot;,&amp;quot;disksize&amp;quot;:20,&amp;quot;leasedays&amp;quot;:1,&amp;quot;environment_type&amp;quot;:&amp;quot;dev&amp;quot;,&amp;quot;description&amp;quot;:&amp;quot;my_description&amp;quot;}&#39; -k http://localhost:8080/v1/nodes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It should write something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2015/11/10 13:56:51 POST        /v1/nodes       NodeCreate      2.520673ms
ok
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And something like this in the output of the ruby code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Creating the node with parameters: linux S 20 1 dev my_description
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s all folks! What&amp;rsquo;s left:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;To implement the other methods to be &amp;ldquo;&lt;a href=&#34;https://en.wikipedia.org/wiki/Create,_read,_update_and_delete&#34;&gt;CRUD&lt;/a&gt;&amp;rdquo; compliant&lt;/li&gt;
&lt;li&gt;To implement an authentication and accreditation mechanism (JWT, Oauth, ?)&lt;/li&gt;
&lt;li&gt;To change the implementation of the RPC client to use a pool instead of a single connection&lt;/li&gt;
&lt;li&gt;To implement the swagger interface and documentation of the API&lt;/li&gt;
&lt;li&gt;Whatever fancy stuff you may want from a production ready interface.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You can find all the codes in the github repository &lt;a href=&#34;https://github.com/owulveryck/example-iaas&#34;&gt;here&lt;/a&gt; in the branch &lt;code&gt;iaas-like-restfull-api-based-on-microservices&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Ruby / ZeroMQ / GO</title>
      <link>http://blog.owulveryck.info/2015/10/22/ruby-/-zeromq-/-go/</link>
      <pubDate>Thu, 22 Oct 2015 20:40:36 +0200</pubDate>
      <author>olivier.wulveryck@gmail.com (Olivier Wulveryck)</author>
      <guid>http://blog.owulveryck.info/2015/10/22/ruby-/-zeromq-/-go/</guid>
      <description>

&lt;h1 id=&#34;abtract:0c52c1f9d165cef19abe8f54df707cfc&#34;&gt;Abtract&lt;/h1&gt;

&lt;p&gt;I really like go as a programming language. It is a good tool to develop web restful API service.&lt;/p&gt;

&lt;p&gt;On the other hand, ruby and its framework rails has also been wildly used to achieve the same goal.&lt;/p&gt;

&lt;p&gt;Therefore we may be facing a &amp;ldquo;legacy&amp;rdquo; ruby developpement that we would like to connect to our brand new go framework.
0MQ may be a perfect choice for intefacing the two languages.&lt;/p&gt;

&lt;p&gt;Anyway, it is, at least, a good experience to do a little bit of code to make them communicate.&lt;/p&gt;

&lt;h1 id=&#34;zeromq:0c52c1f9d165cef19abe8f54df707cfc&#34;&gt;ZeroMQ&lt;/h1&gt;

&lt;p&gt;I will use the ZeroMQ version 4 as it is the latest available one.
On top of that, I can see in the &lt;a href=&#34;http://zeromq.org/docs:changes-4-0-0&#34;&gt;release notes&lt;/a&gt; that there is an implementation of a strong encryption, and I may use it later on&lt;/p&gt;

&lt;h1 id=&#34;go:0c52c1f9d165cef19abe8f54df707cfc&#34;&gt;Go&lt;/h1&gt;

&lt;h2 id=&#34;installation-of-the-library:0c52c1f9d165cef19abe8f54df707cfc&#34;&gt;Installation of the library&lt;/h2&gt;

&lt;p&gt;As written in the README file, I try a &lt;code&gt;go get&lt;/code&gt; installation on my chromebook.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~ go get github.com/pebbe/zmq4
# pkg-config --cflags libzmq
Package libzmq was not found in the pkg-config search path.
Perhaps you should add the directory containing `libzmq.pc&#39;
to the PKG_CONFIG_PATH environment variable
No package &#39;libzmq&#39; found
pkg-config: exit status 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The go binding is not a pure go implementation, and it still needs the C library of zmq.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s &lt;em&gt;brew installing&lt;/em&gt; it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~  brew install zmq
==&amp;gt; Downloading http://download.zeromq.org/zeromq-4.1.3.tar.gz
######################################################################## 100.0%
==&amp;gt; ./configure --prefix=/usr/local/linuxbrew/Cellar/zeromq/4.1.3 --without-libsodium
==&amp;gt; make
==&amp;gt; make install
/usr/local/linuxbrew/Cellar/zeromq/4.1.3: 63 files, 3.5M, built in 73 seconds
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s do the go-get again:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~ go get github.com/pebbe/zmq4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;so far so good. Now let&amp;rsquo;s test the installation with a &amp;ldquo;hello world&amp;rdquo; example.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note&lt;/em&gt;: the &lt;a href=&#34;https://github.com/pebbe/zmq4/blob/master/examples&#34;&gt;examples directory&lt;/a&gt; contains a go implementation of all the example of the ZMQ book
I will use the &lt;a href=&#34;https://github.com/pebbe/zmq4/blob/master/examples/hwclient.go&#34;&gt;hello world client&lt;/a&gt; and the &lt;a href=&#34;https://github.com/pebbe/zmq4/blob/master/examples/hwserver.go&#34;&gt;hello world server&lt;/a&gt; for my tests&lt;/p&gt;

&lt;p&gt;The hello world client/server is implementing a Request-Reply patternt and are communicating via a TCP socket.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The server is the &lt;em&gt;replier&lt;/em&gt; and is listening on the TCP port 5555&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;...
func main() {
    //  Socket to talk to clients
    responder, _ := zmq.NewSocket(zmq.REP)
    defer responder.Close()
    responder.Bind(&amp;quot;tcp://*:5555&amp;quot;)
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;The client is the &lt;em&gt;requester&lt;/em&gt; and is dialing the same TCP port&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;...
func main() {
    //  Socket to talk to server
    fmt.Println(&amp;quot;Connecting to hello world server...&amp;quot;)
    requester, _ := zmq.NewSocket(zmq.REQ)
    defer requester.Close()
    requester.Connect(&amp;quot;tcp://localhost:5555&amp;quot;)
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, the client is sending (requesting) a &lt;em&gt;hello&lt;/em&gt; message, and the server is replying a &lt;em&gt;world&lt;/em&gt; message.&lt;/p&gt;

&lt;h2 id=&#34;running-the-example:0c52c1f9d165cef19abe8f54df707cfc&#34;&gt;Running the example&lt;/h2&gt;

&lt;p&gt;First, start the server:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~ cd $GOPATH/src/github.com/pebbe/zmq4/examples
~ go run hwserver.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then the client&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~ cd $GOPATH/src/github.com/pebbe/zmq4/examples
~ go run hwclient.go
Connecting to hello world server...
Sending  Hello 0
Received  World
Sending  Hello 1
Received  World
Sending  Hello 2
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;ruby:0c52c1f9d165cef19abe8f54df707cfc&#34;&gt;Ruby&lt;/h1&gt;

&lt;p&gt;Now let&amp;rsquo;s implement a Ruby client.&lt;/p&gt;

&lt;h2 id=&#34;installation-of-the-library-1:0c52c1f9d165cef19abe8f54df707cfc&#34;&gt;Installation of the library&lt;/h2&gt;

&lt;p&gt;a &lt;em&gt;gem install&lt;/em&gt; is supposed to do the trick:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~ gem install zmq
Building native extensions.  This could take a while...
ERROR:  Error installing zmq:
ERROR: Failed to build gem native extension.

/usr/local/linuxbrew/opt/ruby/bin/ruby -r ./siteconf20151022-23021-1ehwusq.rb extconf.rb
    checking for zmq.h... yes
    checking for zmq_init() in -lzmq... yes
    Cool, I found your zmq install...
    creating Makefile

    make &amp;quot;DESTDIR=&amp;quot; clean

    make &amp;quot;DESTDIR=&amp;quot;
    compiling rbzmq.c
    rbzmq.c: In function &#39;socket_getsockopt&#39;:
    rbzmq.c:968:7: error: &#39;ZMQ_RECOVERY_IVL_MSEC&#39; undeclared (first use in this function)
        case ZMQ_RECOVERY_IVL_MSEC:
        ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Arg!, something went wrong. It looks like there is a version mismatch between th libzmq brew installed and the version expected by the gem
The &lt;em&gt;zmq&lt;/em&gt; gem seems a bit old and there is a &lt;em&gt;FFI&lt;/em&gt; ruby extension with a more active developement.&lt;/p&gt;

&lt;p&gt;Moreover, I have found []the perfect website for the ruby-and-zmq-ignorant(&lt;a href=&#34;https://github.com/andrewvc/learn-ruby-zeromq&#34;&gt;https://github.com/andrewvc/learn-ruby-zeromq&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;As written in the doc, let&amp;rsquo;s install the needed gems via &lt;code&gt;gem install ffi ffi-rzmq zmqmachine&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;let-s-try-the-lib:0c52c1f9d165cef19abe8f54df707cfc&#34;&gt;Let&amp;rsquo;s try the lib&lt;/h2&gt;

&lt;p&gt;Ok, it is now time to run an example&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;require &#39;rubygems&#39;
require &#39;ffi-rzmq&#39;
def error_check(rc)
    if ZMQ::Util.resultcode_ok?(rc)
        false
    else
        STDERR.puts &amp;quot;Operation failed, errno [#{ZMQ::Util.errno}] description [#{ZMQ::Util.error_string}]&amp;quot;
        caller(1).each { |callstack| STDERR.puts(callstack)  }
        true
    end
end

ctx = ZMQ::Context.create(1)
STDERR.puts &amp;quot;Failed to create a Context&amp;quot; unless ctx

req_sock = ctx.socket(ZMQ::REQ)
rc = req_sock.connect(&#39;tcp://127.0.0.1:5555&#39;)
STDERR.puts &amp;quot;Failed to connect REQ socket&amp;quot; unless ZMQ::Util.resultcode_ok?(rc)

2.times do
    rc = req_sock.send_string(&#39;Ruby says Hello&#39;)
    break if error_check(rc)

    rep = &#39;&#39;
    rc = req_sock.recv_string(rep)
    break if error_check(rc)
    puts &amp;quot;Received reply &#39;#{rep}&#39;&amp;quot;
end
error_check(req_sock.close)

ctx.terminate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Running this example with a simple &lt;code&gt;ruby client.rb&lt;/code&gt; command leads to the following errors:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ruby client.rb
Assertion failed: check () (src/msg.cpp:248)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But, my GO server is receiving the messages:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~ go run hwserver.go
Received  Ruby says Hello
Received  Ruby says Hello
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;end-of-show:0c52c1f9d165cef19abe8f54df707cfc&#34;&gt;End of show&lt;/h1&gt;

&lt;p&gt;That&amp;rsquo;s it for now. I think I&amp;rsquo;m facing a bug in the ruby implementation of the libzmq I&amp;rsquo;m using.
Indeed, I&amp;rsquo;ve found an &lt;a href=&#34;https://github.com/chuckremes/ffi-rzmq/issues/118&#34;&gt;issue&lt;/a&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;I will check again later, or I will try on another environement but the essential is here.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>