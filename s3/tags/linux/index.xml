<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux on Olivier Wulveryck&#39;s Tech Blog</title>
    <link>https://blog.owulveryck.info/tags/linux/</link>
    <description>Recent content in Linux on Olivier Wulveryck&#39;s Tech Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>olivier.wulveryck@gmail.com (Olivier Wulveryck)</managingEditor>
    <webMaster>olivier.wulveryck@gmail.com (Olivier Wulveryck)</webMaster>
    <copyright>All rights reserved - 2015/2016</copyright>
    <lastBuildDate>Mon, 29 Aug 2016 21:58:17 +0200</lastBuildDate>
    <atom:link href="https://blog.owulveryck.info/tags/linux/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Getting weather data from the station to the raspberry</title>
      <link>https://blog.owulveryck.info/2016/08/29/getting-weather-data-from-the-station-to-the-raspberry/index.html</link>
      <pubDate>Mon, 29 Aug 2016 21:58:17 +0200</pubDate>
      <author>olivier.wulveryck@gmail.com (Olivier Wulveryck)</author>
      <guid>https://blog.owulveryck.info/2016/08/29/getting-weather-data-from-the-station-to-the-raspberry/index.html</guid>
      <description>

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;A bunch of friends/colleagues offered me a raspberry pi 3.
It may become my VPN gateway, or my firewall, or the brain of my CCTV, or maybe the center of an alarm&amp;hellip;. Maybe a spotify player&amp;hellip;&lt;/p&gt;

&lt;p&gt;Anyway, I have installed raspbian and I&amp;rsquo;m now playing with it.&lt;/p&gt;

&lt;p&gt;Yesterday evening, as I was about to go to bed, I&amp;rsquo;ve had a very bad idea&amp;hellip; I&amp;rsquo;ve linked together my RPI and my Oregon Weather Station.
3 hours later, I was still geeking&amp;hellip;&lt;/p&gt;

&lt;p&gt;As usual in the blog I will explain what I did, what did work, and what did not.&lt;/p&gt;

&lt;h1 id=&#34;attaching-the-devices&#34;&gt;Attaching the devices&lt;/h1&gt;

&lt;p&gt;I&amp;rsquo;ve plugged the device, ok! Now what does the system tells me about it:&lt;/p&gt;

&lt;p&gt;What &lt;code&gt;dmesg&lt;/code&gt; tells me is simply&lt;/p&gt;

&lt;pre&gt;
[ 2256.877522] usb 1-1.4: new low-speed USB device number 5 using dwc_otg
[ 2256.984860] usb 1-1.4: New USB device found, idVendor=0fde, idProduct=ca01
[ 2256.984881] usb 1-1.4: New USB device strings: Mfr=0, Product=1, SerialNumber=0
[ 2256.984894] usb 1-1.4: Product:  
[ 2256.992719] hid-generic 0003:0FDE:CA01.0002: hiddev0,hidraw0: USB HID v1.10 Device [ ] on usb-3f980000.usb-1.4/input0
&lt;/pre&gt;

&lt;h2 id=&#34;finding-the-device&#34;&gt;Finding the device&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;lsusb&lt;/code&gt; gives me the list of the usb devices on my rpi:&lt;/p&gt;

&lt;pre&gt;
# lsusb 
Bus 001 Device 004: ID 0fde:ca01  
Bus 001 Device 003: ID 0424:ec00 Standard Microsystems Corp. SMSC9512/9514 Fast Ethernet Adapter
Bus 001 Device 002: ID 0424:9514 Standard Microsystems Corp. 
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
&lt;/pre&gt;

&lt;p&gt;The first one correspond to my weather station but it belongs to root:&lt;/p&gt;

&lt;pre&gt;
# ls -lrt /dev/bus/usb/001/004
crw------- 1 root root 189, 3 Aug 30 12:45 /dev/bus/usb/001/004
&lt;/pre&gt;

&lt;h2 id=&#34;giving-access-udev&#34;&gt;Giving access: &lt;code&gt;udev&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;The first thing to do is to allow access to my usb device so I won&amp;rsquo;t need to run any program as root.
By default the &lt;code&gt;pi&lt;/code&gt; user belongs to a bunch of groups. One of those is called &lt;code&gt;plugdev&lt;/code&gt;.
It is the one I will use for my experiment.&lt;/p&gt;

&lt;h3 id=&#34;get-information-about-my-device&#34;&gt;Get information about my Device&lt;/h3&gt;

&lt;pre&gt;
# udevadm info /dev/bus/usb/001/004

P: /devices/platform/soc/3f980000.usb/usb1/1-1/1-1.3
N: bus/usb/001/012
E: BUSNUM=001
E: DEVNAME=/dev/bus/usb/001/012
E: DEVNUM=012
E: DEVPATH=/devices/platform/soc/3f980000.usb/usb1/1-1/1-1.3
E: DEVTYPE=usb_device
E: DRIVER=usb
E: ID_BUS=usb
E: ID_MODEL_ENC=\x20
E: ID_MODEL_FROM_DATABASE=WMRS200 weather station
E: ID_MODEL_ID=ca01
E: ID_REVISION=0302
E: ID_SERIAL=0fde_
E: ID_USB_INTERFACES=:030000:
E: ID_VENDOR=0fde
E: ID_VENDOR_ENC=0fde
E: ID_VENDOR_FROM_DATABASE=Oregon Scientific
E: ID_VENDOR_ID=0fde
E: MAJOR=189
E: MINOR=11
E: PRODUCT=fde/ca01/302
E: SUBSYSTEM=__usb__
E: TYPE=0/0/0
E: USEC_INITIALIZED=5929384
&lt;/pre&gt;

&lt;p&gt;I will note the vendor ID and the product ID.
Funny stuff is that it presents itself as a WMRS200 and the model I have is a RMS300, but never mind.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s create the udev rule file using the previous informations about the idVendor and the idProduct and create a special file &lt;code&gt;/dev/weather-station&lt;/code&gt;.
This will make the code more easy as I will be able to hard code the name, and leave the boring task of finding the device aside.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat &amp;lt;&amp;lt; EOF &amp;gt; /etc/udev/rules.d/50-weather-station.rules
# Weather Station
SUBSYSTEM==&amp;quot;usb&amp;quot;, ATTRS{idVendor}==&amp;quot;0fde&amp;quot;, ATTRS{idProduct}==&amp;quot;ca01&amp;quot;, MODE=&amp;quot;0660&amp;quot;, GROUP=&amp;quot;plugdev&amp;quot;, SYMLINK+=&amp;quot;weather-station&amp;quot;
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once done, I can restart udev with &lt;code&gt;sudo /etc/init.d/udev restart&lt;/code&gt; or reload and trigger the rules with &lt;code&gt;udevadm&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;IF something goes wrong, you can check the logs by turning the log level to info, reload the rules and look into the syslog file&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# udevadm control -l info
# udevadm control -R
# # grep -i udev /var/log/syslog 
# 
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# ls -lrt /dev/weather-station                                                                                                               
lrwxrwxrwx 1 root root 15 Aug 29 21:32 /dev/weather-station -&amp;gt; bus/usb/001/007
# ls -lrt /dev/bus/usb/001/007                                                                                                   
crw-rw-r-- 1 root plugdev 189, 6 Aug 29 21:32 /dev/bus/usb/001/007
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So far so good&amp;hellip;&lt;/p&gt;

&lt;h1 id=&#34;accessing-the-data&#34;&gt;Accessing the data&lt;/h1&gt;

&lt;h2 id=&#34;the-libusb&#34;&gt;The libusb&lt;/h2&gt;

&lt;p&gt;Linux has a low level library &amp;ldquo;libusb&amp;rdquo; that make the development of modules easy: &lt;a href=&#34;http://www.libusb.org/wiki/libusb-1.0&#34;&gt;libusb-1.0&lt;/a&gt;.
On my rpi, I can install the development version with a simple &lt;code&gt;sudo apt-get install libusb-1.0-0-dev&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;using-go-the-gousb-library&#34;&gt;Using GO: The &lt;code&gt;gousb&lt;/code&gt; library&lt;/h2&gt;

&lt;p&gt;A binding for the libusb is available through the &lt;a href=&#34;https://github.com/truveris/gousb&#34;&gt;gousb&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;There is also a &lt;strong&gt;lsusb&lt;/strong&gt; version that is available as an example.
Let&amp;rsquo;s grab it with a simple
&lt;code&gt;go get -v github.com/kylelemons/gousb/lsusb&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;and test it&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ~GOPATH/bin/lsusb

001.004 0fde:ca01 WMRS200 weather station (Oregon Scientific)
  Protocol: (Defined at Interface level)
  Config 01:
    --------------
    Interface 00 Setup 00
      Human Interface Device (No Subclass) None
      Endpoint 1 IN  interrupt - unsynchronized data [8 0]
    --------------
001.003 0424:ec00 SMSC9512/9514 Fast Ethernet Adapter (Standard Microsystems Corp.)
  Protocol: Vendor Specific Class
  Config 01:
    --------------
    Interface 00 Setup 00
      Vendor Specific Class
      Endpoint 1 IN  bulk - unsynchronized data [512 0]
      Endpoint 2 OUT bulk - unsynchronized data [512 0]
      Endpoint 3 IN  interrupt - unsynchronized data [16 0]
    --------------
001.002 0424:9514 SMC9514 Hub (Standard Microsystems Corp.)
  Protocol: Hub (Unused) TT per port
  Config 01:
    --------------
    Interface 00 Setup 00
      Hub (Unused) Single TT
      Endpoint 1 IN  interrupt - unsynchronized data [1 0]
    Interface 00 Setup 01
      Hub (Unused) TT per port
      Endpoint 1 IN  interrupt - unsynchronized data [1 0]
    --------------
001.001 1d6b:0002 2.0 root hub (Linux Foundation)
  Protocol: Hub (Unused) Single TT
  Config 01:
    --------------
    Interface 00 Setup 00
      Hub (Unused) Full speed (or root) hub
      Endpoint 1 IN  interrupt - unsynchronized data [4 0]
  --------------
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;rawread&#34;&gt;Rawread&lt;/h2&gt;

&lt;p&gt;I want to read the raw data from the device.
The gousb package comes along with an example named &amp;ldquo;rawread&amp;rdquo;. I&amp;rsquo;m using it:&lt;/p&gt;

&lt;pre&gt;
# rawread git:(master) # go run main.go -device &#34;0fde:ca01&#34;
2016/08/30 14:00:01 Scanning for device &#34;0fde:ca01&#34;...
  Protocol: (Defined at Interface level)
  Config 01:
    --------------
    Interface 00 Setup 00
      Human Interface Device (No Subclass) None
      Endpoint 1 IN  interrupt - unsynchronized data [8 0]
    --------------
2016/08/30 14:00:01 Connecting to endpoint...
2016/08/30 14:00:01 - &amp;usb.Descriptor{Bus:0x1, Address:0x4, Spec:0x110, Device:0x302, Vendor:0xfde, Product:0xca01, Class:0x0, SubClass:0x0, Protocol:0x0, Configs:[]usb.ConfigInfo{usb.ConfigInfo{Config:0x1, Attributes:0x80, MaxPower:0x32, Interfaces:[]usb.InterfaceInfo{usb.InterfaceInfo{Number:0x0, Setups:[]usb.InterfaceSetup{usb.InterfaceSetup{Number:0x0, Alternate:0x0, IfClass:0x3, IfSubClass:0x0, IfProtocol:0x0, Endpoints:[]usb.EndpointInfo{usb.EndpointInfo{Address:0x81, Attributes:0x3, MaxPacketSize:0x8, MaxIsoPacket:0x0, PollInterval:0xa, RefreshRate:0x0, SynchAddress:0x0}}}}}}}}}
2016/08/30 14:00:01 open: usb: claim: libusb: device or resource busy [code -6]
&lt;/pre&gt;

&lt;p&gt;After digging into the documentation and forums about the libusb, it looks like the device is locked by a generic kernel driver.
So I need to detach it first.&lt;/p&gt;

&lt;p&gt;The API call used to detach a kernel driver is &lt;code&gt;libusb_detach_kernel_driver&lt;/code&gt;. Sadly it has not be bound to the golang&amp;rsquo;s library.
Indeed &lt;a href=&#34;https://github.com/jpoirier&#34;&gt;Joseph Poirier&lt;/a&gt; maintain an active fork from the gousb library and he does implement the call.
It&amp;rsquo;s a private method that is called implicitly by another call, so no need to modify the code from rawread to use it.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve switched to his version:&lt;/p&gt;

&lt;pre&gt;
# go get github.com/jpoirier/gousb/rawread
./main -device &#34;0fde:ca01&#34;
2016/08/30 14:12:28 Scanning for device &#34;0fde:ca01&#34;...
  Protocol: (Defined at Interface level)
  Config 01:
    --------------
    Interface 00 Setup 00
      Human Interface Device (No Subclass) None
      Endpoint 1 IN  interrupt - unsynchronized data [8 0]
    --------------
2016/08/30 14:12:28 Connecting to endpoint...
2016/08/30 14:12:28 - &amp;usb.Descriptor{Bus:0x1, Address:0x4, Spec:0x110, Device:0x302, Vendor:0xfde, Product:0xca01, Class:0x0, SubClass:0x0, Protocol:0x0, Configs:[]usb.ConfigInfo{usb.ConfigInfo{Config:0x1, Attributes:0x80, MaxPower:0x32, Interfaces:[]usb.InterfaceInfo{usb.InterfaceInfo{Number:0x0, Setups:[]usb.InterfaceSetup{usb.InterfaceSetup{Number:0x0, Alternate:0x0, IfClass:0x3, IfSubClass:0x0, IfProtocol:0x0, Endpoints:[]usb.EndpointInfo{usb.EndpointInfo{Address:0x81, Attributes:0x3, MaxPacketSize:0x8, MaxIsoPacket:0x0, PollInterval:0xa, RefreshRate:0x0, SynchAddress:0x0}}}}}}}}}
&lt;/pre&gt;

&lt;p&gt;Nothing more because the code ends by&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;  ep, err := dev.OpenEndpoint(uint8(*config), uint8(*iface), uint8(*setup), uint8(*endpoint)|uint8(usb.ENDPOINT_DIR_IN))
  if err != nil {
      log.Fatalf(&amp;quot;open: %s&amp;quot;, err)
  }
  _ = ep 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cool&amp;hellip; Now let&amp;rsquo;s add some code to read from the endpoint (which is an interface and that implements a Read method as described &lt;a href=&#34;https://godoc.org/github.com/jpoirier/gousb/usb#Endpoint&#34;&gt;here&lt;/a&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;  b := make([]byte, 16)
  _, err = ep.Read(b)
  if err != nil {
      log.Fatalf(&amp;quot;read: %s&amp;quot;, err)
  }
  log.Printf(&amp;quot;%v&amp;quot;, b)
  _ = ep 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And run the code:&lt;/p&gt;

&lt;pre&gt;
go run main.go -device &#34;0fde:ca01&#34;
2016/08/30 14:25:58 Scanning for device &#34;0fde:ca01&#34;...
  Protocol: (Defined at Interface level)
    Config 01:
    --------------
    Interface 00 Setup 00
      Human Interface Device (No Subclass) None
      Endpoint 1 IN  interrupt - unsynchronized data [8 0]
    --------------
2016/08/30 14:25:58 Connecting to endpoint...
2016/08/30 14:25:58 - &amp;usb.Descriptor{Bus:0x1, Address:0x4, Spec:0x110, Device:0x302, Vendor:0xfde, Product:0xca01, Class:0x0, SubClass:0x0, Protocol:0x0, Configs:[]usb.ConfigInfo{usb.ConfigInfo{Config:0x1, Attributes:0x80, MaxPower:0x32, Interfaces:[]usb.InterfaceInfo{usb.InterfaceInfo{Number:0x0, Setups:[]usb.InterfaceSetup{usb.InterfaceSetup{Number:0x0, Alternate:0x0, IfClass:0x3, IfSubClass:0x0, IfProtocol:0x0, Endpoints:[]usb.EndpointInfo{usb.EndpointInfo{Address:0x81, Attributes:0x3, MaxPacketSize:0x8, MaxIsoPacket:0x0, PollInterval:0xa, RefreshRate:0x0, SynchAddress:0x0}}}}}}}}}
2016/08/30 14:25:59 [7 0 48 0 48 53 1 255 7 255 0 66 129 239 0 32]
&lt;/pre&gt;

&lt;p&gt;OK! Here are the data, now what I need to figure out, is how to interpret them!&lt;/p&gt;

&lt;h2 id=&#34;decoding-the-protocol&#34;&gt;Decoding the Protocol&lt;/h2&gt;

&lt;p&gt;Internet is a great tool: I&amp;rsquo;ve found a description of the protocol &lt;a href=&#34;http://www.bashewa.com/wmr200-protocol.php&#34;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve read that it was mandatory to send a heartbeat sequence every 30 seconds.
I will implement the heartbeat later. For now I will send it initially to request data from the station:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// This is a hearbeat request (9 bytes array)
h := []byte{0x00, 0x01, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
log.Println(&amp;quot;Sending heartbeat&amp;quot;)
i, err := ep.Write(h)
if err != nil {
    log.Fatal(&amp;quot;Cannot send heartbeat&amp;quot;, err)
}
log.Println(&amp;quot;%v bytes sent&amp;quot;,i)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then read the stream back. Every data payload is separate from the others by a 0xffff sequence.&lt;/p&gt;

&lt;h3 id=&#34;testing-the-sequence-initialization-request&#34;&gt;Testing the sequence initialization request&lt;/h3&gt;

&lt;pre&gt;
 go run main.go -device &#34;0fde:ca01&#34;
2016/08/30 20:02:19 Scanning for device &#34;0fde:ca01&#34;...
Protocol: (Defined at Interface level)
  Config 01:
  --------------
  Interface 00 Setup 00
    Human Interface Device (No Subclass) None
    Endpoint 1 IN  interrupt - unsynchronized data [8 0]
  --------------
  2016/08/30 20:02:19 Connecting to endpoint...
2016/08/30 20:02:19 Sending heartbeat
2016/08/30 20:02:19 heartbeat failed: usb: write: not an OUT endpoint
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;What did² I do wrong?&lt;/strong&gt;
&lt;center&gt;
&lt;img src=&#34;http://imgs.xkcd.com/comics/debugging.png&#34; alt=&#34;XKCD&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;Easy, I didn&amp;rsquo;t RTFM&amp;hellip;
Actually, I didn&amp;rsquo;t read the specification of the USB.&lt;/p&gt;

&lt;p&gt;As described &lt;a href=&#34;http://events.linuxfoundation.org/sites/events/files/slides/elc_2014_usb_0.pdf&#34;&gt;here&lt;/a&gt; the USB is a &lt;strong&gt;host-controlled&lt;/strong&gt; bus which means that:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Nothing on the bus happens without the host first initiating it.&lt;/li&gt;
&lt;li&gt;Devices cannot initiate a transaction.&lt;/li&gt;
&lt;li&gt;The USB is a Polled Bus&lt;/li&gt;
&lt;li&gt;The Host polls each device, requesting data or sending data&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The possibles transaction are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;IN : Device to Host&lt;/li&gt;
&lt;li&gt;OUT: Host to Device&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;On top of that, a device may handle 1 to N configuration which handles 1 to N endpoints which may be considered IN or OUT.&lt;/p&gt;

&lt;p&gt;My weather station has only one endpoint which is IN.
Therefore I will not be able to send information to the station from the host. What I will be able to send is a IN token to get data on the bus.&lt;/p&gt;

&lt;pre&gt;
# lsusb -v
...
Endpoint Descriptor:
  bLength                 7
  bDescriptorType         5
  bEndpointAddress     0x81  EP 1 IN
  bmAttributes            3
    Transfer Type            Interrupt
    Synch Type               None
    Usage Type               Data
  wMaxPacketSize     0x0008  1x 8 bytes
  bInterval              10
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt; I also see that the endpoint is an interrupt&lt;/p&gt;

&lt;h1 id=&#34;to-be-continued&#34;&gt;To be continued&amp;hellip;&lt;/h1&gt;

&lt;p&gt;This blog post is quiet long, and I haven&amp;rsquo;t finished my research yet. Indeed I think that there is enough information for the post to go live.
I will post a part II as soon as I will have time to continue my experiments with the USB device and the rpi.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>